/**
 * License: MIT
 * Generated on 2019/06/13 18:20
 * Author: Przemysław Tyczyński | https://tyczynski.dev
 * Copyright (c) 2019 Przemysław Tyczyński
 */

define(function() {
	'use strict';
	const e = { root: null, rootMargin: '0px', threshold: 1, visibleClass: 'in-visible' };
	return class {
		constructor(s = '.js-scroll-observer', t = {}) {
			if (s instanceof Element) this.elements = [s];
			else if (s instanceof NodeList) this.elements = Array.from(s);
			else if (s instanceof String) this.elements = Array.from(document.querySelectorAll(s));
			else {
				if (!(s instanceof Array))
					throw new Error(
						"The argument 'elements' passed is not an instance of Element, NodeList, String or Array",
					);
				this.elements = s;
			}
			(this.config = Object.assign({}, e, t)),
				window.addEventListener('scroll', this.prepareElements.bind(this));
		}
		prepareElements() {
			(this.elements = this.elements.filter(e => {
				const [s, t] = (function(e) {
					const { top: s, height: t } = e.getBoundingClientRect();
					return [s <= window.innerHeight && s + t >= 0, t + s <= 0 ? 'up' : 'down'];
				})(e);
				return s || (e.classList.add(t), e.classList.add(this.config.preparedClass)), !s;
			})),
				window.removeEventListener('scroll', this.prepareElements.bind(this)),
				this.initObserver();
		}
		initObserver() {
			this.observer = new IntersectionObserver(this.callback.bind(this), {
				root: this.config.root,
				rootMargin: this.config.rootMargin,
				threshold: this.config.threshold,
			});
			for (let e = 0; e < this.elements.length; e += 1) this.observer.observe(this.elements[e]);
		}
		callback(e) {
			e.forEach(e => {
				const { target: s } = e;
				e.isIntersecting && (s.classList.add(this.config.visibleClass), this.observer.unobserve(s));
			});
		}
		observe(e) {
			this.observer.observe(e);
		}
	};
});
